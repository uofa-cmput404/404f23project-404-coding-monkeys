# DFB pg. 165
from django.contrib.auth.models import AbstractUser
from django.db import models
import uuid
from static.vars import ENDPOINT
from django.dispatch import receiver

class WhitelistController(models.Model):
    id = models.IntegerField(primary_key=True, editable=False)
    whitelist_enabled = models.BooleanField(default=False) # is the whitelist enabled (True means admin must approve users, False means users are auto-approved)
    
    def __str__(self):
        return "Change Whitelist Settings"
    
    class Meta: # https://stackoverflow.com/questions/8368937/change-model-class-name-in-django-admin-interface
        verbose_name = "Whitelist Settings"
        verbose_name_plural = 'Whitelist Settings'

class AuthorUser(AbstractUser):
    def check_whitelist():
        whitelist_obj = WhitelistController.objects.get(id=1) 
        whitelist_enabled = whitelist_obj.whitelist_enabled # is the whitelist enabled?
        print("WHITELIST ENABLED FOR NEWEST (WL OFF) USER?")
        print(whitelist_enabled)
        return not whitelist_enabled # return whether user is_active or not (opposite value of whitelist_enabled)
    
    #id - should be generated by db automatically
    uuid = models.CharField(max_length=36, unique=True)
    type = models.CharField(default="author",max_length=6)
    username = models.CharField(max_length=20, unique=True) # https://www.reddit.com/r/django/comments/id2ch0/user_models_username_max_length/
    # change from IP address field to URL field
    host = models.URLField(default = ENDPOINT) # hardcoded localhost for now
    url = models.URLField(null=True, blank=True) #TODO setup proper page
    github = models.URLField(null=True, blank=True)
    profile_image = models.URLField(null=True, blank=True) # optional
    is_active = models.BooleanField(default=check_whitelist()) # is the user account active. True when approved/whitelist disabled, False when whitelist enabled.

    # necessary to edit profile using uuid in url
    slug = models.SlugField(max_length=50, unique=True)
    def save(self, *args, **kwargs):
        self.url = f"{ENDPOINT}authors/{self.uuid}"
        self.slug = self.uuid
        super(AuthorUser, self).save(*args, **kwargs)

@receiver(models.signals.post_save, sender=AuthorUser)
def execute_after_save(sender, instance, created, *args, **kwargs):
    if created:
        pass
        #print("USER WAS CREATED")

class Followers(models.Model):
    author = models.ForeignKey(AuthorUser, on_delete=models.CASCADE, related_name='author', to_field="uuid")
    followers = models.JSONField(default=list)

    def __str__(self): # show summary in django admin view tooltip 
        return self.author.username + "'s " + "Followers"

# This table will delete requests once they have been fulfilled and added to the Follower table
class FollowRequests(models.Model):
    summary = models.CharField(max_length=100)
    # could possible have a boolean for requester and recipient to see if they are local to our node, and instead
    # of storing an entire dictionary of information it can just be an author id which we will retrieve data from in
    # the AuthorUser table. Will see.
    requester_uuid = models.CharField(max_length=36)
    requester = models.JSONField(default=dict)
    recipient_uuid = models.CharField(max_length=36)
    recipient = models.JSONField(default=dict)
    sent_at = models.DateTimeField(auto_now_add=True)

    def __str__(self): # show summary in django admin view tooltip 
        return self.summary

    # can only request somebody once
    class Meta:
        unique_together = ('requester', 'recipient')

